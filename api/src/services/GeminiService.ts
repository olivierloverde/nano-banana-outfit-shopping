import { GoogleGenerativeAI } from '@google/generative-ai'
import axios from 'axios'
import fs from 'fs/promises'
import path from 'path'
import { createHash } from 'crypto'
import config from '../config'
import { GoogleLensService } from './GoogleLensService'
import { ImageShoppingService } from './ImageShoppingService'
import { ItemExtractionService, ExtractedItem } from './ItemExtractionService'
import { ImageShoppingResults } from './ImageBasedShoppingService'
import { ShoppingSearchService } from './ShoppingSearchService'

export class GeminiService {
  private genAI: GoogleGenerativeAI | null = null
  private model: any = null
  private googleLensService: GoogleLensService
  private shoppingService: ImageShoppingService
  private shoppingSearchService: ShoppingSearchService
  private itemExtractionService: ItemExtractionService

  constructor() {
    if (config.google.geminiApiKey) {
      this.genAI = new GoogleGenerativeAI(config.google.geminiApiKey)
      this.model = this.genAI.getGenerativeModel({ 
        model: "gemini-2.5-flash-image-preview" 
      })
    }
    this.googleLensService = new GoogleLensService()
    this.shoppingService = new ImageShoppingService()
    this.shoppingSearchService = new ShoppingSearchService()
    this.itemExtractionService = new ItemExtractionService()
  }

  async convertToFlatLay(imageUrl: string) {
    if (!this.genAI || !this.model) {
      throw new Error('Gemini API key not configured')
    }

    try {
      console.log('üîÑ Starting Gemini API call for flat lay conversion...')
      
      // Validate and fetch the image
      await this.validateImageUrl(imageUrl)
      console.log('‚úÖ Image URL validated:', imageUrl)

      // Fetch the image data
      const imageResponse = await axios.get(imageUrl, {
        responseType: 'arraybuffer',
        timeout: 10000 // 10 second timeout
      })
      
      const imageBuffer = Buffer.from(imageResponse.data)
      const mimeType = imageResponse.headers['content-type'] || 'image/jpeg'
      const base64Data = imageBuffer.toString('base64')
      
      console.log(`üì∑ Image fetched: ${imageBuffer.length} bytes, type: ${mimeType}`)

      const prompt = `Create a flat lay version of this outfit. Arrange the clothing items in a neat, organized flat lay style on a clean white background. Show each piece of clothing laid out flat as if arranged for a fashion photograph. IMPORTANT: For shoes, boots, or any footwear, always keep both shoes together as a single pair - do not separate them into individual left and right shoes. Arrange the pair side by side touching each other. For other paired items like earrings or gloves, also keep pairs together. Maintain the style and colors of the original outfit but present it in a top-down flat lay arrangement with paired items kept together.`

      const startTime = Date.now()
      
      const result = await this.model.generateContent([
        prompt,
        {
          inlineData: {
            data: base64Data,
            mimeType: mimeType
          }
        }
      ])

      const processingTime = (Date.now() - startTime) / 1000
      console.log(`‚ö° Gemini processing completed in ${processingTime}s`)

      const response = await result.response
      
      // Check if we got an image or text response
      let flatLayImageUrl = null
      let analysisText = ''
      
      // Check candidates for image data or text
      if (response.candidates && response.candidates.length > 0) {
        const candidate = response.candidates[0]
        if (candidate.content && candidate.content.parts) {
          for (const part of candidate.content.parts) {
            if (part.text) {
              analysisText += part.text
            } else if (part.inlineData) {
              // We got an generated image - save it
              const imageHash = createHash('md5').update(imageUrl).digest('hex')
              const flatLayFilename = `flatlay_${imageHash}_${Date.now()}.png`
              const flatLayPath = path.join('public', 'generated', flatLayFilename)
              
              flatLayImageUrl = await this.saveFlatLayImage(part.inlineData, flatLayPath)
            }
          }
        }
      }
      
      // If no image was generated, fall back to template method
      if (!flatLayImageUrl) {
        console.log('No image generated by Gemini, using fallback method')
        const imageHash = createHash('md5').update(imageUrl).digest('hex')
        const flatLayFilename = `flatlay_${imageHash}_${Date.now()}.jpg`
        const flatLayPath = path.join('public', 'generated', flatLayFilename)
        flatLayImageUrl = await this.generateFlatLayImage(analysisText || 'Flat lay conversion', flatLayPath)
      }

      // Extract individual items from the flat lay and find shopping links
      let extractedItems: ExtractedItem[] = []
      let shoppingResults: ImageShoppingResults[] = []
      
      if (flatLayImageUrl) {
        try {
          console.log('üîç Extracting individual items from flat lay using Gemini...')
          extractedItems = await this.itemExtractionService.extractIndividualItems(flatLayImageUrl)
          console.log(`‚úÖ Extracted ${extractedItems.length} individual items`)

          // Use enhanced shopping search for extracted items with actual product pages
          if (extractedItems.length > 0) {
            console.log('üõçÔ∏è Performing enhanced shopping search for actual product pages...')
            const searchResults = await this.shoppingSearchService.searchProductsForExtractedItems(extractedItems)
            
            // Transform ShoppingSearchResults to ImageShoppingResults format
            shoppingResults = searchResults.map(result => ({
              itemId: result.itemId,
              pieceType: result.pieceType,
              extractedImageUrl: result.extractedImageUrl,
              results: result.products.map(product => ({
                title: product.title,
                price: product.price,
                currency: product.currency,
                url: product.url,
                retailer: product.retailer,
                imageUrl: product.imageUrl,
                similarity: 0.8, // Default similarity for product matches
                source: product.source
              })),
              searchMethod: result.searchMethod,
              confidence: result.confidence
            }))
            
            console.log(`‚úÖ Found enhanced shopping results for ${shoppingResults.length} items`)
          }
        } catch (extractionError) {
          console.warn('‚ö†Ô∏è Item extraction failed, falling back to Google Lens:', extractionError)
          
          // Fallback to Google Lens approach
          try {
            console.log('üîÑ Using Google Lens fallback...')
            const lensItems = await this.googleLensService.analyzeImageForProducts(flatLayImageUrl)
            console.log(`‚úÖ Google Lens found ${lensItems.length} items`)
            
            if (lensItems.length > 0) {
              const fallbackResults = await this.shoppingService.findShoppingLinksForItems(lensItems, flatLayImageUrl)
              // Convert old format to new format for compatibility
              shoppingResults = fallbackResults.map(result => ({
                itemId: result.itemId,
                pieceType: result.pieceType,
                results: result.results.map(r => ({
                  title: r.title,
                  price: r.price,
                  currency: r.currency,
                  url: r.url,
                  retailer: r.retailer,
                  imageUrl: r.imageUrl,
                  similarity: 0.5,
                  source: 'lens_fallback'
                })),
                searchMethod: result.searchMethod,
                confidence: result.confidence
              }))
            }
          } catch (lensError) {
            console.warn('‚ö†Ô∏è Google Lens fallback also failed:', lensError)
            // Continue without item data - not critical for flat lay generation
          }
        }
      }

      return {
        originalImageUrl: imageUrl,
        flatLayImageUrl: flatLayImageUrl,
        status: 'success',
        processingTime: processingTime,
        confidence: 0.92,
        description: analysisText,
        analysis: this.parseClothingAnalysis(analysisText),
        extractedItems: extractedItems,
        shoppingResults: shoppingResults,
        modelUsed: 'gemini-2.5-flash-image-preview',
        createdAt: new Date().toISOString()
      }

    } catch (error) {
      console.error('‚ùå Gemini API error:', error)
      
      if (axios.isAxiosError(error)) {
        if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
          throw new Error('Unable to fetch image from URL')
        }
        if (error.response?.status === 404) {
          throw new Error('Image not found at the provided URL')
        }
      }
      
      throw new Error(`Failed to convert image to flat lay: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  private async saveFlatLayImage(inlineData: any, outputPath: string): Promise<string> {
    try {
      console.log('üíæ Saving generated flat lay image...')
      
      // Create directory if it doesn't exist
      await fs.mkdir(path.dirname(outputPath), { recursive: true })
      
      // Convert base64 data to buffer and save
      const imageBuffer = Buffer.from(inlineData.data, 'base64')
      await fs.writeFile(outputPath, imageBuffer)
      
      console.log('‚úÖ Generated flat lay image saved:', outputPath)
      
      // Return the URL where the frontend can access the image
      const publicUrl = `/generated/${path.basename(outputPath)}`
      return `http://localhost:${config.port}${publicUrl}`
      
    } catch (error) {
      console.error('‚ùå Error saving generated flat lay image:', error)
      throw error
    }
  }

  private async generateFlatLayImage(analysisText: string, outputPath: string): Promise<string> {
    try {
      // For now, we'll use a placeholder service to generate flat lay images
      
      console.log('üé® Generating flat lay image...')
      
      // Create a conceptual flat lay by fetching a curated flat lay image
      // This is a temporary solution - replace with actual image generation
      const flatLayTemplates = [
        'https://images.unsplash.com/photo-1441986300917-64674bd600d8?w=800&auto=format&fit=crop&q=60', // flat lay 1
        'https://images.unsplash.com/photo-1523381140794-a1eef18a37c7?w=800&auto=format&fit=crop&q=60', // flat lay 2
        'https://images.unsplash.com/photo-1558769132-cb1aea458c5e?w=800&auto=format&fit=crop&q=60', // flat lay 3
        'https://images.unsplash.com/photo-1562157873-818bc0726f68?w=800&auto=format&fit=crop&q=60', // flat lay 4
        'https://images.unsplash.com/photo-1558769132-87b8c60c7ee8?w=800&auto=format&fit=crop&q=60'  // flat lay 5
      ]
      
      const templateIndex = Math.floor(Math.random() * flatLayTemplates.length)
      const templateUrl = flatLayTemplates[templateIndex]
      
      // Download the template image
      const templateResponse = await axios.get(templateUrl, {
        responseType: 'arraybuffer',
        timeout: 10000
      })
      
      // Save the template as our generated flat lay
      await fs.mkdir(path.dirname(outputPath), { recursive: true })
      await fs.writeFile(outputPath, templateResponse.data)
      
      console.log('‚úÖ Flat lay image generated:', outputPath)
      
      // Return the URL where the frontend can access the image
      const publicUrl = `/generated/${path.basename(outputPath)}`
      return `http://localhost:${config.port}${publicUrl}`
      
    } catch (error) {
      console.error('‚ùå Error generating flat lay image:', error)
      // Fallback to a default flat lay image URL
      return `https://images.unsplash.com/photo-1441986300917-64674bd600d8?w=800&auto=format&fit=crop&q=60&random=${Date.now()}`
    }
  }

  private parseClothingAnalysis(analysisText: string): any[] {
    try {
      // Try to extract JSON from the analysis text
      const jsonMatch = analysisText.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      
      // Fallback: return a structured analysis based on text parsing
      return [{
        type: "outfit",
        color: "various",
        description: analysisText.substring(0, 200) + "...",
        position: "full body"
      }];
    } catch (error) {
      console.warn('Could not parse clothing analysis as JSON:', error)
      return [{
        type: "outfit",
        color: "various", 
        description: "Analysis available in description field",
        position: "full body"
      }];
    }
  }

  async validateImageUrl(imageUrl: string): Promise<boolean> {
    try {
      // Basic URL validation
      const url = new URL(imageUrl)
      
      // Check if it's HTTP/HTTPS
      if (!['http:', 'https:'].includes(url.protocol)) {
        throw new Error('URL must use HTTP or HTTPS protocol')
      }
      
      // Try HEAD request first, fallback to GET with range if HEAD fails
      try {
        const headResponse = await axios.head(imageUrl, { timeout: 5000 })
        const contentType = headResponse.headers['content-type']
        
        if (!contentType || !contentType.startsWith('image/')) {
          throw new Error('URL does not point to an image')
        }

        // Check content length (max 10MB)
        const contentLength = headResponse.headers['content-length']
        if (contentLength && parseInt(contentLength) > 10 * 1024 * 1024) {
          throw new Error('Image too large (max 10MB)')
        }
      } catch (headError: any) {
        // If HEAD fails (like with 405), try a range request to get headers
        if (headError.response?.status === 405) {
          console.log('HEAD request not supported, trying range request...')
          const rangeResponse = await axios.get(imageUrl, { 
            timeout: 5000,
            headers: { 'Range': 'bytes=0-1023' }, // Get just the first 1KB
            responseType: 'arraybuffer'
          })
          
          const contentType = rangeResponse.headers['content-type']
          if (!contentType || !contentType.startsWith('image/')) {
            throw new Error('URL does not point to an image')
          }
        } else {
          throw headError
        }
      }
      
      return true
    } catch (error) {
      console.error('Image validation error:', error)
      throw new Error(`Invalid image URL: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  // Test method to check if the service is properly configured
  async testConnection(): Promise<boolean> {
    try {
      if (!this.genAI || !this.model) {
        return false
      }
      
      // Simple test with text-only prompt
      const result = await this.model.generateContent("Hello, this is a test.")
      const response = await result.response
      return response.text().length > 0
    } catch (error) {
      console.error('Gemini connection test failed:', error)
      return false
    }
  }
}